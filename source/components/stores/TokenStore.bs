import "pkg:/components/stores/stores.bs"
import "pkg:/components/utils/Base58.bs"
import "pkg:/components/http/http.bs"

const AUTH0_BASE_URL = "https://prod-elv.us.auth0.com/"
const AUTH0_CLIENT_ID = "***REMOVED***"

const TOKEN_REGISTRY_SECTION = "tokens"

const PERSISTED_FIELDS = ["fabricToken", "walletAddress"]

sub init()
    m.registry = createObject("roRegistrySection", TOKEN_REGISTRY_SECTION)
    keepFieldsSyncedWithRegistry(PERSISTED_FIELDS)
end sub

sub wipe(_ = invalid)
    for each field in PERSISTED_FIELDS
        m.top[field] = invalid
    end for
end sub

' All [trackedFields] must be values in m.top.
' This methods reads the current registry and sets the corresponding fields in m.top.
' Then it indefinitely observes changes to these fields and writes them to registry as they change.
sub keepFieldsSyncedWithRegistry(trackedFields as roArray)
    values = m.registry.readMulti(trackedFields)
    for each field in trackedFields
        print `[TokenStore] restore token: ${field}=${values[field]}`
        m.top[field] = values[field]
        m.top.observeField(field, "onTrackedFieldChange")
    end for
end sub

sub onTrackedFieldChange(message)
    field = message.getField()
    data = message.getData()
    print `[TokenStore] Detected token change. Persisting ${field}=${data}`
    m.registry.write(field, data)
    m.registry.flush()
end sub

function GetActivationData(metamask = false) as object
    if metamask <> invalid and metamask
        baseUrl = stores.fabricConfigStore()@.getAuthdBaseUrl()
        return http.post(`${baseUrl}/wlt/login/redirect/metamask`, {
            op: "create",
            ' This is hardcoded to the Main network, will not work on Demo
            dest: "https://wallet.contentfabric.io?action=login&mode=login&response=code&source=code#/login"
        })
    else
        return http.post(`${AUTH0_BASE_URL}oauth/device/code`, {
            client_id: AUTH0_CLIENT_ID,
            scope: "openid profile email offline_access"
        })
    end if
end function

' Poll Auth0 to see if user completed activation and there's an id/access/refresh token waiting for us
function checkDeviceAuthorization(deviceCode) as object
    httpPromise = http.post(`${AUTH0_BASE_URL}oauth/token`, {
        client_id: AUTH0_CLIENT_ID,
        grant_type: "urn:ietf:params:oauth:grant-type:device_code"
        device_code: deviceCode
    })

    return promises.chain(httpPromise).then(sub(response) as object
        if response.code = 200
            m.top.idToken = response.json.id_token
            m.top.accessToken = response.json.access_token
            m.top.refreshToken = response.json.refresh_token
        end if
        return response
    end sub).toPromise()
end function

' Same as [checkDeviceAuthorization] but for metamask - skips a step and give FabricToken directly.
' However - token can never be refreshed
function checkMetamaskAuthorization(code, passcode) as object
    baseUrl = stores.fabricConfigStore()@.getAuthdBaseUrl()
    return promises.chain(http.get(`${baseUrl}/wlt/login/redirect/metamask/${code}/${passcode}`)).then(function(response)
        if response.code = 200
            payload = parseJson(response.json.payload)
            m.top.fabricToken = payload.token
            m.top.walletAddress = payload.addr
        end if
        return response
    end function).toPromise()
end function

' Called after id token is set
function fetchFabricToken(tenantId as string)
    baseUrl = stores.fabricConfigStore()@.getAuthdBaseUrl()
    context = { baseUrl: baseUrl, tid: tenantId }
    return promises.chain(http.post(`${baseUrl}/wlt/login/jwt`, { ext: { share_email: true } }), context).then(
    function(response, context)
        m.top.clusterToken = response.json.token
        m.top.walletAddress = response.json.addr
        print "saved cluster token", m.top.clusterToken
        print "saved wallet address", m.top.walletAddress

        ' Get fabricToken from server. "clusterToken" will be embedded in the headers by HttpTask.
        channelId = createObject("roDeviceInfo").GetChannelClientId()
        return http.post(`${context.baseUrl}/wlt/sign/csat`, { tid: context.tid, nonce: channelId })
    end function).then(function(response, context)
        m.top.fabricToken = response.json.token
        return "success"
    end function
    ).toPromise()
end function
