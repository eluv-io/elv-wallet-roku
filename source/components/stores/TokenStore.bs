import "pkg:/components/stores/stores.bs"
import "pkg:/components/utils/Base58.bs"
import "pkg:/components/stores/Env.bs"
import "pkg:/components/screens/signin/SignInUtil.bs"
import "pkg:/components/utils/Time.bs"
import "pkg:/components/http/http.bs"

const TOKEN_REGISTRY_SECTION = "tokens"

const PERSISTED_FIELDS = ["fabricToken", "tokenExpiration", "refreshToken", "loginProvider", "walletAddress", "email", "clusterToken"]

const PREEMPTIVE_REFRESH_THRESHOLD_SECONDS = 5 * 60 ' 5 minutes

sub init()
    m.registry = createObject("roRegistrySection", TOKEN_REGISTRY_SECTION)
    keepFieldsSyncedWithRegistry(PERSISTED_FIELDS)

    if m.top.loginProvider = "auth0"
        ' Incompatible data from previous versions - wipe all persisted tokens.
        ' Currently only "ory" and "auth0_${domain}" are supported.
        wipe()
    end if

    queuePreemptiveRefresh()
end sub

sub queuePreemptiveRefresh()
    if m.preemtiveRefreshTimer <> invalid
        m.preemtiveRefreshTimer.control = "stop"
    end if
    ' We're using formatJson/ParseJson to force conversion between string and longint
    ' Otherwise we'll get a Float, which loses precision for large epoch times
    expiry = ParseJson(m.top.tokenExpiration ?? "")
    if expiry = invalid or strNullOrEmpty(m.top.refreshToken)
        Logger.log("No token expiration or refresh token set; skipping preemptive refresh scheduling.")
        return
    end if

    timeTillExpire = expiry / 1000 - time.now()
    timeout = Max(timeTillExpire - PREEMPTIVE_REFRESH_THRESHOLD_SECONDS, 0)
    Logger.log(`Scheduling preemptive token refresh in ${timeout} seconds (token expires in ${timeTillExpire} seconds).`)
    m.preemtiveRefreshTimer = time.setTimer(function()
        Logger.log("Preemtive token refresh triggered.")
        refreshTokens()
    end function, timeout)
end sub

' Assumes m.top.refreshToken is set
function refreshTokens(_ = invalid) as object
    Logger.log("Starting token refresh")
    request = http.post(stores.fabricConfigStore()@.getAuthdBaseUrl() + "/wlt/refresh/csat", {
        refresh_token: m.top.refreshToken
        nonce: createObject("roDeviceInfo").GetChannelClientId()
        last_csat: m.top.fabricToken
        ' Time in seconds the new token is valid for. Only include for testing short expiry.
        ' exp: PREEMPTIVE_REFRESH_THRESHOLD_SECONDS + 20
    })
    return promises.chain(request).then(sub(response)
        if response.code = 200
            result = response.json
            m.top.fabricToken = result.token
            m.top.tokenExpiration = FormatJson(result.expires_at)
            m.top.refreshToken = result.refresh_token
            queuePreemptiveRefresh()
            Logger.log("[TokenStore] Token refresh done.")
        else
            Logger.log("[TokenStore] Token refresh failed.")
        end if
    end sub).toPromise()
end function

sub wipe(_ = invalid)
    for each field in PERSISTED_FIELDS
        m.top[field] = invalid
    end for
end sub

' All [trackedFields] must be values in m.top.
' This methods reads the current registry and sets the corresponding fields in m.top.
' Then it indefinitely observes changes to these fields and writes them to registry as they change.
sub keepFieldsSyncedWithRegistry(trackedFields as roArray)
    values = m.registry.readMulti(trackedFields)
    for each field in trackedFields
        print `[TokenStore] restore field: ${field}=${values[field]}`
        m.top[field] = values[field]
        m.top.observeField(field, "onTrackedFieldChange")
    end for
end sub

sub onTrackedFieldChange(message)
    field = message.getField()
    data = message.getData()
    print `[TokenStore] Detected field change. Persisting ${field}=${data}`
    m.registry.write(field, data)
    m.registry.flush()
end sub

function GetActivationData(property) as object
    loginProvider = SignInUtil.getLoginProvider(property)
    baseUrl = stores.fabricConfigStore()@.getAuthdBaseUrl()
    deviceInfo = createObject("roDeviceInfo")
    dest = Env.walletUrl()
    dest += `?action=login&mode=login&response=code&source=code`
    dest += `&pid=${property.id}`
    ' TODO: veryify that this is different across devices
    dest += `&installId=${sha512(deviceInfo.GetChannelClientId())}`
    dest += `&origin=${deviceInfo.GetModelDisplayName()}`
    if loginProvider <> "ory" then dest += `&clear=`
    ' For testing: expire 20 seconds after preemptive refresh threshold (ttl is in hours)
    ' dest += `&ttl=${(PREEMPTIVE_REFRESH_THRESHOLD_SECONDS + 20) / 60 / 60}`
    dest += "#/login"
    req = http.post(`${baseUrl}/wlt/login/redirect/metamask`, {
        op: "create",
        dest: dest
    })
    context = { loginProvider: loginProvider }
    return promises.chain(req, context).then(function(response, context)
        activationData = response.json
        activationData.loginProvider = context.loginProvider
        return activationData
    end function).toPromise()
end function

function sha512(input as string) as string
    bytes = createObject("roByteArray")
    bytes.fromAsciiString(input)
    digest = CreateObject("roEVPDigest")
    digest.Setup("sha512")
    return digest.Process(bytes)
end function

function checkDeviceAuthorization(activation) as object
    baseUrl = stores.fabricConfigStore()@.getAuthdBaseUrl()
    context = { loginProvider: activation.loginProvider }
    url = `${baseUrl}/wlt/login/redirect/metamask/${activation.id}/${activation.passcode}`
    return promises.chain(http.get(url), context).then(function(response, context)
        if response.code = 200
            payload = parseJson(response.json.payload)
            m.top.fabricToken = payload.token
            m.top.tokenExpiration = FormatJson(payload.expiresAt) ' convert longint to string without scientific notation
            m.top.refreshToken = payload.refreshToken
            m.top.clusterToken = payload.clusterToken
            m.top.walletAddress = lcase(payload.addr)
            m.top.userEmail = payload.email
            m.top.loginProvider = context.loginProvider
            queuePreemptiveRefresh()
        end if
        return response
    end function).toPromise()
end function

function passwordAuth(email, password, property, isSignUp as boolean)
    if strNullOrEmpty(email) then return promises.reject({ message: "Empty email/username" })
    if strNullOrEmpty(password) then return promises.reject({ message: "Empty password" })

    baseUrl = stores.fabricConfigStore()@.getAuthdBaseUrl()
    if isSignUp
        url = `${baseUrl}/wlt/ory/sign_up`
    else
        url = `${baseUrl}/wlt/ory/sign_in`
    end if

    body = {
        email: email
        password: password
        media_property: property.id
        nonce: createObject("roDeviceInfo").GetChannelClientId()
    }

    return promises.chain(http.post(url, body)).then(function(response)
        Logger.log(`Sign up/in response: ${response.json}`)
        if response.code = 200
            m.top.fabricToken = response.json.fabric_token
            m.top.refreshToken = response.json.refresh_token
            m.top.clusterToken = response.json.cluster_token
            m.top.userEmail = response.json.email
            m.top.walletAddress = lcase(response.json.user_addr)
            return "success"
        else
            return promises.reject({ reason: response.json?.error?.messages?[0]?.id ?? response.json })
        end if
    end function).catch(function(e)
        Logger.log(`Sign up/in error: ${e}`)
        ' Clear all fields we might have touched, and then send the same error forward
        m.top.userEmail = invalid
        m.top.clusterToken = invalid
        m.top.walletAddress = invalid
        m.top.fabricToken = invalid
        return promises.reject(e)
    end function).toPromise()
end function

function Max(a as dynamic, b as dynamic)
    if a > b
        return a
    else
        return b
    end if
end function
