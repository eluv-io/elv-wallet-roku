import "pkg:/components/http/http.bs"
import "pkg:/components/utils/NftOps.bs"
import "pkg:/components/utils/RouterUtils.bs"
import "pkg:/components/utils/RichText.bs"

const ITEM_HEIGHT = 270

sub init()
    m.title = m.top.findNode("title")
    m.subtitle = m.top.findNode("subtitle")
    m.subtitleAnim = m.top.findNode("subtitleAnimation")
    m.subtitleInterp = m.top.findNode("subtitleInterpolator")
    m.rowList = m.top.findNode("rowList")
    m.bgImage = m.top.findNode("bgImage")

    m.rowList.observeFieldScoped("currFocusRow", "onFocusedRowChanged")
    m.rowList.observeFieldScoped("rowItemSelected", "onItemSelected")
    m.rowList.setfocus(true)
end sub

sub onItemSelected()
    itemIndex = m.rowList.rowItemSelected
    mediaItem = m.rowList.content.getChild(itemIndex[0]).getChild(itemIndex[1]).aa
    NftOps.launchMedia(mediaItem)
end sub

sub onFocusedRowChanged()
    ' Only show m.subtitle when first row is selected.
    if m.subtitleAnim.state <> "running"
        if m.rowList.itemFocused = 0 and m.rowList.currFocusRow > 0 and m.subtitle.scale[1] > 0
            m.subtitleAnim.control = "stop"
            m.subtitleInterp.reverse = true
            m.subtitleAnim.control = "start"
        else if m.rowList.itemFocused > 0 and m.rowList.currFocusRow < 1 and m.subtitle.scale[1] < 1
            m.subtitleAnim.control = "stop"
            m.subtitleInterp.reverse = false
            m.subtitleAnim.control = "start"
        end if
    end if
end sub

sub onNftItemChanged()
    ' At this point, our other apps observe ContentStore for live updates of this NFT.
    ' For Roku, we can just hold onto the node as it was clicked and display it "statically".
    ' This is fine because the NFT details shouldn't really change frequently, or as you're observing it.
    ' And also, Roku sucks and it's annoying and painful to do it, so I'll pass for now.
    nft = m.top.nft.sourceNft
    m.title.text = nft._name
    m.subtitle.text = RichText.stripFormatting(nft.nft_template.description_rich_text ?? nft.nft_template.description)

    m.bgImage.uri = findBgImage(nft)
    updateRowList(nft)
end sub

function findBgImage(nft) as dynamic
    for each item in nft._featured_media
        bgImage = item.background_image_tv
        if bgImage <> invalid
            return NftOps.assetLinkToUrl(bgImage)
        end if
    end for
    return ""
end function


sub updateRowList(nft)
    root = createObject("roSGNode", "ContentNode")
    createFeaturedMediaRow(nft, root)
    createSectionRows(nft, root)
    m.rowList.content = root
    m.rowList.numrows = root.getChildCount()
end sub

sub createFeaturedMediaRow(nft, root)
    if nft._featured_media.count() = 0
        return
    end if

    row = root.createChild("ContentNode")
    NftOps.mediaItemsToNodes(nft._featured_media, row, ITEM_HEIGHT)
end sub

sub createSectionRows(nft, root)
    if nft._sections.count() = 0
        return
    end if

    for each section in nft._sections
        createSectionRow(section, root)
    end for
end sub

sub createSectionRow(section, root)
    row = root.createChild("ContentNode")
    row.title = section.name
    for each collection in section.collections
        ' The first collection adds its items to the Section row itself. Subsequent collections add a new row to the root.
        collectionRow = row.getChildCount() = 0 ? row : root.createChild("ContentNode")
        populateCollectionRow(collection, collectionRow)
    end for
end sub

' Doesn't create new rows because the first Collection in a Section will add its items to the Section row itself.
sub populateCollectionRow(collection, row)
    name = collection.name
    if name <> invalid and name <> ""
        ' If the row already has a title, it's the Section title and we need to add a linebreak before appending the collection name
        if row.title <> ""
            row.title += chr(10)
        end if
        row.title += name
    end if
    NftOps.mediaItemsToNodes(collection.media, row, ITEM_HEIGHT)
end sub
