import "pkg:/components/http/http.bs"
import "pkg:/components/utils/NftOps.bs"
import "pkg:/components/utils/RichText.bs"

const ITEM_HEIGHT = 270

sub init()
    m.title = m.top.findNode("title")
    m.subtitle = m.top.findNode("subtitle")
    m.rowList = m.top.findNode("rowList")
    m.bgImage = m.top.findNode("bgImage")

    m.rowList.setfocus(true)
end sub

sub onNftItemChanged()
    ' At this point, our other apps observe ContentStore for live updates of this NFT.
    ' For Roku, we can just hold onto the node as it was clicked and display it "statically".
    ' This is fine because the NFT details shouldn't really change frequently, or as you're observing it.
    ' And also, Roku sucks and it's annoying and painful to do it, so I'll pass for now.
    nft = m.top.nft.sourceNft
    m.title.text = nft._name
    m.subtitle.text = RichText.stripFormatting(nft.nft_template.description_rich_text)

    m.bgImage.uri = findBgImage(nft)
    updateRowList(nft)
end sub

function findBgImage(nft) as dynamic
    for each item in nft._featured_media
        bgImage = item.background_image_tv
        if bgImage <> invalid
            return NftOps.assetLinkToUrl(bgImage)
        end if
    end for
    return invalid
end function


sub updateRowList(nft)
    root = createObject("roSGNode", "ContentNode")
    createFeaturedMediaRow(nft, root)
    createSectionRows(nft, root)
    m.rowList.content = root
    m.rowList.numrows = root.getChildCount()
end sub

sub createFeaturedMediaRow(nft, root)
    if nft._featured_media.count() = 0
        return
    end if

    row = root.createChild("ContentNode")
    createNodes(row, nft._featured_media)
end sub

sub createSectionRows(nft, root)
    if nft._sections.count() = 0
        return
    end if

    for each section in nft._sections
        createSectionRow(section, root)
    end for
end sub

sub createSectionRow(section, root)
    row = root.createChild("ContentNode")
    row.title = section.name
    for each collection in section.collections
        ' The first collection adds its items to the Section row itself. Subsequent collections add a new row to the root.
        collectionRow = row.getChildCount() = 0 ? row : root.createChild("ContentNode")
        populateCollectionRow(collection, collectionRow)
    end for
end sub

' Doesn't create new rows because the first Collection in a Section will add its items to the Section row itself.
sub populateCollectionRow(collection, row)
    name = collection.name
    if name <> invalid and name <> ""
        ' If the row already has a title, it's the Section title and we need to add a linebreak before appending the collection name
        if row.title <> ""
            row.title += chr(10)
        end if
        row.title += name
    end if
    createNodes(row, collection.media)
end sub

' Creates an [AAContentNode] for each item in [items], as a child node of [root]
sub createNodes(root, items)
    for each item in items
        node = root.createChild("AAContentNode")
        node.aa = item
        aspectRatio = lcase(item.image_aspect_ratio ?? "") = "wide" ? 16 / 9 : 1
        node.addField("FHDItemWidth", "float", false)
        node.FHDItemWidth = ITEM_HEIGHT * aspectRatio
    end for
end sub
