import "pkg:/components/utils/UrlUtil.bs"
import "pkg:/components/utils/Toast.bs"
import "pkg:/components/utils/AspectRatio.bs"
import "pkg:/components/screens/property/DisplaySettings.bs"
import "pkg:/components/utils/Logger.bs"
import "pkg:/components/screens/property/SectionConstants.bs"
import "pkg:/components/utils/NftOps.bs"
import "pkg:/components/utils/MediaItemUtil.bs"
import "pkg:/components/stores/permissions/PermissionUtil.bs"
import "pkg:/components/stores/stores.bs"

const SUPPORTED_ITEM_TYPES = { "media": 1, "external_link": 1, "property_link": 1, "subproperty_link": 1, "page_link": 1 }

sub init()
    m.bgImage = m.top.findNode("bgImage")
    m.rowList = m.top.findNode("rowList")
    listLeftPadding = m.rowList.translation[0]
    m.rowList.rowWidth = 1920 - listLeftPadding
    m.rowList.itemClippingRect = { x: -listLeftPadding, y: 0, width: 1920, height: 1080 }
    m.rowList.clippingRect = [-listLeftPadding, 0, 1920, 1080]
    observe(m.rowList, "rowItemSelected", onSectionItemSelected)

    ' Dummy label that isn't attached to the screen. We use that to measure text sizes.
    m.dummyLabel = createObject("roSGNode", "TvLabel")
end sub

sub onPageLinkChanged()
    link = m.top.linkData
    ' Load property object and save in m.top.property
    promises.chain(stores.propertyStore()@.getPropertyById(link.propertyId)).then(sub (property)
        m.top.property = property
    end sub)
end sub

sub onPropertyChanged()
    property = m.top.property

    pageId = m.top.linkData?.pageId
    if pageId <> invalid
        ' Observing a specific page will skip the property permissions check.
        ' As long as properties don't link to specific pages in other properties,
        ' this should be fine.
        pagePromise = stores.propertyStore()@.getPageById(property, pageId)
    else
        ' The default case. Not passing mainPage here to make sure we check the
        ' Property permissions before we check the page permissions,
        pagePromise = promises.resolve(invalid)
    end if
    promises.chain(pagePromise, property).then(function(page, property)
        return getFirstAuthorizedPage(property, page, {})
    end function).then(sub (page, property)
        m.page = page
        stores.propertyStore()@.fetchSections(property, page)
        observe(stores.propertyStore(), "sections", onSectionsChanged)
        onSectionsChanged()
    end sub)

end sub

' Returns a Promise with the page to display
function getFirstAuthorizedPage(property, page, visitedPageIds)
    ' redirect function fetches the next page object and recursively checks permissions
    redirect = function(redirectPageId, property, visitedPageIds)
        context = { property: property, visitedPageIds: visitedPageIds }
        return promises.chain(stores.propertyStore()@.getPageById(property, redirectPageId), context).then(function(page, context)
            return getFirstAuthorizedPage(context.property, page, context.visitedPageIds)
        end function).toPromise()
    end function

    if page = invalid
        ' No specific page provided, check Property permissions
        if PermissionUtil.showAlternatePage(property.permissions._property)
            Logger.log(`Property not authorized, redirecting to alternate page`)
            return redirect(property.permissions._property.alternate_page_id, property, visitedPageIds)
        else if PermissionUtil.showPurchaseOptions(property.permissions._property)
            ' Show purchase options page for property...
            Toast.show("to be impl: property purchase options")
            return promises.reject("to be impl: property purchase options")
        else
            ' We're authorized to view the property, default to main_page and check its permissions
            return getFirstAuthorizedPage(property, property.main_page, visitedPageIds)
        end if
    else
        ' This is a request for a specific page, ignore Property permissions, or we'll get stuck in a never-ending loop.
        pagePermissions = page.permissions._page
        shouldRedirect = PermissionUtil.showAlternatePage(pagePermissions)
        redirectPageId = shouldRedirect ? pagePermissions.alternate_page_id : invalid
        if pagePermissions.authorized = true
            Logger.log(`Authorized to view page '${page.id}'`)
            return promises.resolve(page)
        else if redirectPageId = page.id or visitedPageIds.doesExist(redirectPageId)
            ' We already checked this page id, or this is a self-reference.
            ' Either way we've completed a cycle without finding a page we are allowed to view.
            Logger.log(`FIXME: Circular page permission problem!`)
            ' throw? router().pop?
        else
            ' Page is unauthorized, but redirect is valid
            Logger.log(`Reached unauthorized page ${page.id}, redirecting to ${redirectPageId}}`)
            visitedPageIds[page.id] = 1
            return redirect(redirectPageId, property, visitedPageIds)
        end if
    end if
end function

sub onSectionsChanged()
    Logger.log(source_function_name)
    property = m.top.property
    sections = stores.propertyStore().sections[`${property?.id}_${m.page.id}`]
    if sections = invalid then return
    content = createObject("roSGNode", "ContentNode")
    heroSectionBgImage = invalid

    ' Rows that contain no focusable elements will add their content to [decorations],
    ' then the first following that is focusable will add pending decorations to their title row
    decorations = []
    for each section in sections
        sectionToNodes(section, content, decorations)

        ' Find the first hero section and use its background as the page background.
        if heroSectionBgImage = invalid and section.type = "hero"
            for each heroItem in section.hero_items
                if heroItem.display?.background_image <> invalid
                    heroSectionBgImage = heroItem.display?.background_image
                    exit for
                end if
            end for
        end if
    end for

    if content.getChildCount() = 0
        ' Make focus transparent
        m.rowList.focusBitmapBlendColor = "#00000000"
    else
        ' Make sure focus is not transparent from a previous SectionChange
        m.rowList.focusBitmapBlendColor = "#FFFFFFFF"
    end if

    if decorations.count() > 0
        Logger.log(`Unfocusable rows at end of List. Adding an empty row`)
        row = createNewSection()
        dumpDecorations(row, decorations)
        content.appendChild(row)
    end if

    m.bgImage.uri = UrlUtil.imageLinkToUrl(heroSectionBgImage ?? m.page.layout.background_image, m.bgImage.height)

    updateListHeights(content)

    m.rowList.content = content
end sub

sub updateListHeights(content)
    listTopPadding = SectionConstants.PROPERTY_LIST_TOP_PADDING

    rowCount = content.getChildCount()
    rowHeights = createObject("roArray", rowCount, false)
    rowZoomHeights = createObject("roArray", rowCount, false)

    rowItemHeights = createObject("roArray", rowCount, false)
    rowItemZoomHeights = createObject("roArray", rowCount, false)

    rowItemYOffsets = createObject("roArray", rowCount, false)
    rowItemZoomYOffsets = createObject("roArray", rowCount, false)

    dummyLabel = m.dummyLabel
    dummyLabel.update({
        text: "A"
        fontStle: "body_32"
        maxLines: 1
    })
    titleFontHeight = dummyLabel.boundingRect().height
    rowTitleOffsets = createObject("roArray", rowCount, false)

    bottomPadding = 36
    for i = 0 to rowCount - 1
        row = content.getChild(i)
        itemHeight = row.desiredHeight ?? 200
        rowHeight = itemHeight + SectionConstants.SECTION_TOP_PADDING + bottomPadding
        if strNotEmpty(row.title)
            rowHeight += titleFontHeight + 36 ' a lil' extra padding below title
        end if

        decorations = row.customDecorations ?? []
        for each decoration in decorations
            rowHeight += decoration.height ?? 0
        end for

        rowHeights[i] = rowHeight
        rowZoomHeights[i] = rowHeight + listTopPadding
        rowItemHeights[i] = itemHeight
        rowItemZoomHeights[i] = itemHeight

        rowItemYOffsets[i] = rowHeight - itemHeight - bottomPadding
        rowItemZoomYOffsets[i] = rowItemYOffsets[i] + listTopPadding
    end for

    rowList = m.rowList
    rowList.rowHeight = rowHeights
    rowList.rowZoomHeight = rowZoomHeights
    rowList.rowItemHeight = rowItemHeights
    rowList.rowItemZoomHeight = rowItemZoomHeights
    rowList.rowItemYOffset = rowItemYOffsets
    rowList.rowItemZoomYOffset = rowItemZoomYOffsets
    rowList.rowTitleOffset = rowTitleOffsets
end sub

' Each "section" from the backend might end up being 0-n rows on the UI
sub sectionToNodes(section, rootNode, decorations)
    if shouldHideSection(section) then return

    newRows = invalid
    if section.type = "automatic" or section.type = "manual" or section.type = "search"
        newRows = createCarouselSection(section, decorations)
    else if section.type = "hero"
        newRows = createHeroSections(section, decorations)
    else if section.type = "container"
        ' TODO: impl section containers
    end if

    newRows = newRows ?? []
    if newRows.count() > 0
        ' If we have any new rows, dump decorations into the first one
        dumpDecorations(newRows[0], decorations)
    end if

    rootNode.appendChildren(newRows)
end sub

function shouldHideSection(section)
    if section.permissions?._content?.authorized <> true then return true
    if section.display.hide_on_tv = true then return true
    hasNoItems = (section.content ?? []).count() = 0 and (section.hero_items ?? []).count() = 0
    if hasNoItems then return true
    ' TODO:
    ' if type=contrainer and all subsections hidden -> return true
    return false
end function

function createCarouselSection(section, decorations)
    rowHeight = 270
    titleLabelSettings = {
        fontStyle: "20_medium"
        maxLines: 1
        wrap: true
    }
    ' Set it once for all following calls to [calcMediaItemRatio].
    ' This is error-prone because we have an implicit assumption that no other code with change
    ' the settings of m.dummyLabel until the end of the for-loop;
    ' But it's more efficient than settings the same values in every iteration.
    m.dummyLabel.update(titleLabelSettings)

    isBannerSection = section.display.display_format = "banner"
    itemNodes = []
    displayLimit = isBannerSection ? 0 : section.display?.display_limit ?? 0
    for each item in section.content
        node = createCarouselItemNode(item, rowHeight, isBannerSection, titleLabelSettings)
        if node <> invalid
            itemNodes.push(node)
        end if
        ' don't stop when we reach the limit (count=limit), but only after we went over
        if displayLimit > 0 and itemNodes.count() > displayLimit
            Logger.log(`Went over displayLimit, stopping node conversion for section ${section.id}`)
            ' Short-circuit out, since the rest of the SectionItems won't be rendered anyway
            exit for
        end if
    end for

    totalItems = itemNodes.count()
    if totalItems = 0
        ' Now items in Section, don't render section
        return []
    end if

    if isBannerSection
        ' Create a whole row for every item of a Banner section. That's the only way to get items in different rows
        ' This has a potential bug where section bg images will "restart" for every item.
        ' Solid color bg will also act weird when scrolling between rows.
        ' Also ignore display limit / viewall for banner sections
        rows = []
        for i = 0 to totalItems - 1
            row = createNewSection(section.display)
            row.update({ desiredHeight: rowHeight }, true)
            if i = 0
                ' Only show title above the first banner
                row.title = section.display?.title
            end if
            row.appendChild(itemNodes[i])
            rows.push(row)
        end for
        return rows
    else
        row = createNewSection(section.display)
        row.update({ desiredHeight: rowHeight }, true)
        row.title = section.display?.title

        ' If set to 0, it means no limit, so we can show as many items as there are.
        displayLimit = displayLimit = 0 ? totalItems : displayLimit

        ' Append all the nodes we created to the row, up to displayLimit
        row.appendChildren(itemNodes.slice(0, displayLimit))

        if totalItems > displayLimit or totalItems > SectionConstants.VIEW_ALL_THRESHOLD
            viewAll = row.createChild("AAContentNode")
            viewAll.aa = { "type": "ViewAllButton" }
            viewAll.update({ aspectRatio: 0.4 }, true)
        end if
        return [row]
    end if
end function

' Returns a node for [item] if it needs to be rendered, or [invalid] otherwise
function createCarouselItemNode(item, rowHeight, isBannerSection, titleLabelSettings)
    bannerImageLink = isBannerSection ? item.banner_image : invalid

    if isBannerSection and bannerImageLink = invalid
        Logger.log(`Section item without banner_image configured, inside a section with display_format=banner. dropping item.`)
        return invalid
    end if

    result = invalid
    if PermissionUtil.isHidden(item.permissions._content)
        ' Hidden item, don't render anything
        return invalid
    else if SUPPORTED_ITEM_TYPES.doesExist(item.type)
        result = createObject("roSGNode", "AAContentNode")
        if item.media <> invalid
            ' TODO: take into account SectionItem.use_media_settings
            display = item.media
        else
            display = item.display
        end if

        if isBannerSection
            ratio = invalid ' Let the code below calculate the real ratio
        else
            ratio = calcMediaItemRatio(display, rowHeight)
        end if
        result.update({
            aa: { "type": "CarouselItem", item: item, titleLabelSettings: titleLabelSettings },
            aspectRatio: ratio
        }, true)
    else if false
        ' TODO: handle PurchaseItem
    end if

    ' Any item type can be displayed as a banner, so take whatever was created and slap the banner on it
    if result <> invalid and isBannerSection
        aa = result.aa
        aa.bannerImageLink = bannerImageLink
        ' Banners should take up the full width of the screen, minus the rowList horiz-padding
        width = 1920 - (m.rowList.translation[0] * 2)
        result.update({
            aa: aa
            aspectRatio: width / rowHeight
        }, true)
    end if

    return result
end function

' Returns [invalid] when [media=invalid] or doesn't have a thumbnail defined.
' Assumes m.dummyLabel is already loaded with the correct settings to match the Title label in the CarouselItem
function calcMediaItemRatio(media, cardTotalHeight)
    thumbnailRatio = DisplaySettings.getThumbnailAndRatio(media)?.aspectRatio
    if thumbnailRatio = invalid
        ' this includes a check for media=invalid as well
        return invalid
    end if
    ' Start off with the thumbnail taking up the entire card
    thumbnailHeight = cardTotalHeight
    if strNotEmpty(media?.title)
        ' If a title exists, remove the height it will take in the card
        thumbnailHeight -= (m.dummyLabel.boundingRect().height + SectionConstants.CAROUSEL_CARD_TITLE_TOP_PADDING + SectionConstants.CAROUSEL_CARD_TITLE_BOTTOM_PADDING)
        ' "round" down to the closest multiple of 3 (roku ui scaling factor)
        thumbnailHeight -= thumbnailHeight mod 3
    end if
    ' Calculate the width required to display the thumbnail correctly, given the new height
    thumbnailWidth = thumbnailRatio * thumbnailHeight
    ' Round down to a multiple of 3 to prevent scaling issues
    thumbnailWidth -= thumbnailWidth mod 3

    ' Finally, the total ratio for the card:
    return thumbnailWidth / cardTotalHeight
end function

function createHeroSections(section, decorations)
    dummyLabel = m.dummyLabel
    items = section.hero_items ?? []
    rows = []
    for each item in items
        if item.display?.logo <> invalid
            ' Create banner from Hero logo
            decorations.push({
                "type": "BannerItem",
                height: 180
                width: 1260
                content: { imageLink: item.display.logo }
            })
            decorations.push({
                "type": "Spacer"
                height: 81
            })
        end if

        if strNotEmpty(item.display?.title)
            labelSettings = {
                text: item.display.title,
                maxLines: 1
                wrap: false
                fontStyle: "header_48"
            }
            ' measure Title height
            dummyLabel.update(labelSettings)
            decorations.push({
                "type": "TextItem",
                height: dummyLabel.boundingRect().height
                width: SectionConstants.TEXT_MAX_WIDTH
                content: labelSettings
            })
            decorations.push({
                "type": "Spacer"
                height: 27
            })
        end if

        if strNotEmpty(item.display?.description)
            ' Figure out if Description needs to be focusable or not:
            ' If it fits without ellipsizing, then there's no need to focus on it
            labelSettings = {
                "type": "TextItem"
                fontStyle: "label_24"
                text: item.display.description
                width: SectionConstants.TEXT_MAX_WIDTH
                maxLines: 3
                wrap: true
            }
            dummyLabel.update(labelSettings)
            ' Calling boundingRect() triggers some measuring logic in the label
            ' and [isTextEllipsized] will have a correct value only after calling it, so do that first
            height = dummyLabel.boundingRect().height
            descriptionFocusable = dummyLabel.isTextEllipsized
            ' Reset for next use
            dummyLabel.width = 0

            ' If description is focusable, we can make it an actual row, and add the title/logo as decorations
            ' if it's not, then add all 3 elements to [decorations] and let them be added to the next row
            if descriptionFocusable
                row = createNewSection()
                textItem = row.createChild("AAContentNode")
                textItem.update({ aspectRatio: SectionConstants.TEXT_MAX_WIDTH / height }, true)
                textItem.aa = labelSettings
                row.update({ desiredHeight: height }, true)
                dumpDecorations(row, decorations)

                rows.push(row)
            else
                decorations.push({
                    "type": "TextItem",
                    height: height
                    width: SectionConstants.TEXT_MAX_WIDTH
                    content: labelSettings
                })
            end if
            ' Whether or not Description is focusable, add a spacer before the next line
            decorations.push({
                "type": "Spacer"
                height: 72
            })
        end if
    end for
    return rows
end function

function createNewSection(display = invalid)
    section = createObject("roSGNode", "AAContentNode")
    if display <> invalid
        section.update({ display: display }, true)
    end if
    return section
end function

sub onSectionItemSelected(event)
    index = m.rowList.rowItemSelected ' [rowIndex, itemIndex]
    item = m.rowList.content.getChild(index[0]).getChild(index[1])
    itemType = item.aa.type
    if itemType = "CarouselItem"
        onSectionItemClicked(item.aa.item)
    else if itemType = "TextItem"
        Toast.show(`TODO: show dialog with text: ${left(item.aa.text, 10)}...`)
    else if itemType = "Spacer"
        ' No-Op
    else
        Toast.show(`to be impl: type=${itemType}`)
    end if
end sub

sub onSectionItemClicked(sectionItem)
    if sectionItem.media <> invalid
        onMediaItemClicked(sectionItem.media)
    else if sectionItem.type = "external_link"
        qrView = createObject("roSGNode", "ExternalContentQrDialog")
        qrView.showLinkText = true
        qrView.includeToken = false
        qrView.link = sectionItem.url
        createObject("roSGNode", "FullscreenDialog").showView = qrView
    else if sectionItem.type = "property_link"
        navigateToPage(sectionItem.property_id, sectionItem.property_page_id)
    else if sectionItem.type = "subproperty_link"
        navigateToPage(sectionItem.subproperty_id, sectionItem.subproperty_page_id)
    else if sectionItem.type = "page_link"
        navigateToPage(m.top.property.id, sectionItem.page_id)
    else
        Toast.show(`to be impl: click on ${sectionItem.type}`)
    end if
end sub

' PropertyId is required.
' PageId is optional
sub navigateToPage(propertyId as string, pageId as dynamic)
    propView = createObject("roSGNode", "PropertyDetail")
    propView.linkData = { propertyId: propertyId, pageId: pageId }
    router()@.show({ view: propView })
end sub

sub onMediaItemClicked(media)
    permissions = media.permissions._content
    if PermissionUtil.showAlternatePage(permissions)
        Toast.show("TODO: show alt page")
        return
    else if PermissionUtil.showPurchaseOptions(permissions)
        Toast.show("TODO: show purchase options")
        return
    else if PermissionUtil.isDisabled(permissions)
        Toast.show("Media Disabled")
        return
    else if permissions.authorized = false and permissions.behavior <> "show_if_unauthorized"
        ' There's also an error-case where the user isn't authorized but we don't know which behavior to apply
        Logger.log(`Media unauthorized but behavior unknown. Ignoring click.`)
        return
    end if

    if media.live_video = true
        if not MediaItemUtils.isStartedLive(media)
            view = CreateObject("roSGNode", "UpcomingVideo")
            view.media = media
            view.property = m.top.property
            router()@.show({ view: view })
            return
        end if
        ' This is a LIVE video that's valid to view, continue normally
    end if

    videoPlayerView = CreateObject("roSGNode", "VideoPlayer")
    videoPlayerView.propertyMedia = {
        propertyId: m.top.property.id
        mediaId: media.id
        title: media.display_title ?? media.title
    }
    router()@.show({ view: videoPlayerView })
end sub

sub dumpDecorations(row, decorations)
    customDecorations = row.customDecorations ?? []
    customDecorations.append(decorations)
    row.update({ customDecorations: customDecorations }, true)
    decorations.clear()
end sub
