import "pkg:/components/utils/UrlUtil.bs"
import "pkg:/components/utils/Toast.bs"
import "pkg:/components/utils/AspectRatio.bs"
import "pkg:/components/screens/property/DisplaySettings.bs"
import "pkg:/components/utils/Logger.bs"
import "pkg:/components/screens/property/SectionConstants.bs"
import "pkg:/components/utils/NftOps.bs"
import "pkg:/components/utils/MediaItemUtil.bs"
import "pkg:/components/stores/stores.bs"

sub init()
    m.bgImage = m.top.findNode("bgImage")
    m.rowList = m.top.findNode("rowList")
    listLeftPadding = m.rowList.translation[0]
    m.rowList.rowWidth = 1920 - listLeftPadding
    m.rowList.itemClippingRect = { x: -listLeftPadding, y: 0, width: 1920, height: 1080 }
    m.rowList.clippingRect = [-listLeftPadding, 0, 1920, 1080]
    observe(m.rowList, "rowItemSelected", onSectionItemSelected)

    ' Dummy label that isn't attached to the screen. We use that to measure text sizes.
    m.dummyLabel = createObject("roSGNode", "TvLabel")
end sub

sub onPropertyChanged()
    property = m.top.property

    ' TODO: figure out page according to permissions
    m.page = property.main_page

    stores.propertyStore()@.fetchSections(property, m.page)
    stores.propertyStore().ObserveFieldScoped("sections", "onSectionsChanged")
    onSectionsChanged()
end sub

sub onSectionsChanged()
    Logger.log(source_function_name)
    property = m.top.property
    sections = stores.propertyStore().sections[`${property?.id}_${m.page.id}`]
    if sections = invalid then return
    content = createObject("roSGNode", "ContentNode")
    heroSectionBgImage = invalid

    ' Rows that contain no focusable elements will add their content to [decorations],
    ' then the first following that is focusable will add pending decorations to their title row
    decorations = []
    for each section in sections
        sectionToNodes(section, content, decorations)

        ' Find the first hero section and use its background as the page background.
        if heroSectionBgImage = invalid and section.type = "hero"
            for each heroItem in section.hero_items
                if heroItem.display?.background_image <> invalid
                    heroSectionBgImage = heroItem.display?.background_image
                    exit for
                end if
            end for
        end if
    end for

    if content.getChildCount() = 0
        ' Make focus transparent
        m.rowList.focusBitmapBlendColor = "#00000000"
    else
        ' Make sure focus is not transparent from a previous SectionChange
        m.rowList.focusBitmapBlendColor = "#FFFFFFFF"
    end if

    if decorations.count() > 0
        Logger.log(`Unfocusable rows at end of List. Adding an empty row`)
        row = createNewSection()
        dumpDecorations(row, decorations)
        content.appendChild(row)
    end if

    m.bgImage.uri = UrlUtil.imageLinkToUrl(heroSectionBgImage ?? m.page.layout.background_image, m.bgImage.height)

    updateListHeights(content)

    m.rowList.content = content
end sub

sub updateListHeights(content)
    listTopPadding = SectionConstants.PROPERTY_LIST_TOP_PADDING

    rowCount = content.getChildCount()
    rowHeights = createObject("roArray", rowCount, false)
    rowZoomHeights = createObject("roArray", rowCount, false)

    rowItemHeights = createObject("roArray", rowCount, false)
    rowItemZoomHeights = createObject("roArray", rowCount, false)

    rowItemYOffsets = createObject("roArray", rowCount, false)
    rowItemZoomYOffsets = createObject("roArray", rowCount, false)

    dummyLabel = m.dummyLabel
    dummyLabel.update({
        text: "A"
        fontStle: "body_32"
        maxLines: 1
    })
    titleFontHeight = dummyLabel.boundingRect().height
    rowTitleOffsets = createObject("roArray", rowCount, false)

    bottomPadding = 36
    for i = 0 to rowCount - 1
        row = content.getChild(i)
        itemHeight = row.desiredHeight ?? 200
        rowHeight = itemHeight + SectionConstants.SECTION_TOP_PADDING + bottomPadding
        if strNotEmpty(row.title)
            rowHeight += titleFontHeight + 36 ' a lil' extra padding below title
        end if

        decorations = row.customDecorations ?? []
        for each decoration in decorations
            rowHeight += decoration.height ?? 0
        end for

        rowHeights[i] = rowHeight
        rowZoomHeights[i] = rowHeight + listTopPadding
        rowItemHeights[i] = itemHeight
        rowItemZoomHeights[i] = itemHeight

        rowItemYOffsets[i] = rowHeight - itemHeight - bottomPadding
        rowItemZoomYOffsets[i] = rowItemYOffsets[i] + listTopPadding
    end for

    rowList = m.rowList
    rowList.rowHeight = rowHeights
    rowList.rowZoomHeight = rowZoomHeights
    rowList.rowItemHeight = rowItemHeights
    rowList.rowItemZoomHeight = rowItemZoomHeights
    rowList.rowItemYOffset = rowItemYOffsets
    rowList.rowItemZoomYOffset = rowItemZoomYOffsets
    rowList.rowTitleOffset = rowTitleOffsets
end sub

' Each "section" from the backend might end up being 0-n rows on the UI
sub sectionToNodes(section, rootNode, decorations)
    if shouldHideSection(section) then return

    newRows = invalid
    if section.type = "automatic" or section.type = "manual" or section.type = "search"
        newRows = createCarouselSection(section, decorations)
    else if section.type = "hero"
        newRows = createHeroSections(section, decorations)
    else if section.type = "container"
        ' TODO: impl section containers
    end if

    newRows = newRows ?? []
    if newRows.count() > 0
        ' If we have any new rows, dump decorations into the first one
        dumpDecorations(newRows[0], decorations)
    end if

    rootNode.appendChildren(newRows)
end sub

function shouldHideSection(section)
    if section.permissions?._content?.authorized <> true then return true
    if section.display.hide_on_tv = true then return true
    hasNoItems = (section.content ?? []).count() = 0 and (section.hero_items ?? []).count() = 0
    if hasNoItems then return true
    ' TODO:
    ' if type=contrainer and all subsections hidden -> return true
    ' if all items are hidden -> return true
    return false
end function

function createCarouselSection(section, decorations)
    row = createNewSection(section.display)
    row.update({ desiredHeight: 270 }, true)
    row.title = section.display?.title

    totalItems = section.content.count()
    displayLimit = section.display?.display_limit ?? totalItems
    ' If set to 0, it means no limit, so we can show as many items as there are.
    displayLimit = displayLimit = 0 ? totalItems : displayLimit

    titleLabelSettings = {
        fontStyle: "20_medium"
        maxLines: 1
        wrap: true
    }
    ' Set it once for all following calls to [calcMediaItemRatio].
    ' This is error-prone because we have an implicit assumption that no other code with change
    ' the settings of m.dummyLabel until the end of the for-loop;
    ' But it's more efficient than settings the same values in every iteration.
    m.dummyLabel.update(titleLabelSettings)

    for each item in section.content.slice(0, displayLimit)
        child = row.createChild("AAContentNode")
        child.update({
            aa: { "type": "CarouselItem", item: item, titleLabelSettings: titleLabelSettings },
            aspectRatio: calcMediaItemRatio(item.media, row.desiredHeight)
        }, true)
    end for

    if totalItems > displayLimit or totalItems > SectionConstants.VIEW_ALL_THRESHOLD
        viewAll = row.createChild("AAContentNode")
        viewAll.aa = { "type": "ViewAllButton" }
        viewAll.update({ aspectRatio: 0.4 }, true)
    end if
    return [row]
end function

' Returns [invalid] when [media=invalid] or doesn't have a thumbnail defined.
' Assumes m.dummyLabel is already loaded with the correct settings to match the Title label in the CarouselItem
function calcMediaItemRatio(media, cardTotalHeight)
    thumbnailRatio = DisplaySettings.getThumbnailAndRatio(media)?.aspectRatio
    if thumbnailRatio = invalid
        ' this includes a check for media=invalid as well
        return invalid
    end if
    ' Start off with the thumbnail taking up the entire card
    thumbnailHeight = cardTotalHeight
    if strNotEmpty(media?.title)
        ' If a title exists, remove the height it will take in the card
        thumbnailHeight -= (m.dummyLabel.boundingRect().height + SectionConstants.CAROUSEL_CARD_TITLE_TOP_PADDING + SectionConstants.CAROUSEL_CARD_TITLE_BOTTOM_PADDING)
        ' "round" down to the closest multiple of 3 (roku ui scaling factor)
        thumbnailHeight -= thumbnailHeight mod 3
    end if
    ' Calculate the width required to display the thumbnail correctly, given the new height
    thumbnailWidth = thumbnailRatio * thumbnailHeight
    ' Round down to a multiple of 3 to prevent scaling issues
    thumbnailWidth -= thumbnailWidth mod 3

    ' Finally, the total ratio for the card:
    return thumbnailWidth / cardTotalHeight
end function

function createHeroSections(section, decorations)
    dummyLabel = m.dummyLabel
    items = section.hero_items ?? []
    rows = []
    for each item in items
        if item.display?.logo <> invalid
            ' Create banner from Hero logo
            decorations.push({
                "type": "BannerItem",
                height: 180
                width: 1260
                content: { imageLink: item.display.logo }
            })
            decorations.push({
                "type": "Spacer"
                height: 81
            })
        end if

        if strNotEmpty(item.display?.title)
            labelSettings = {
                text: item.display.title,
                maxLines: 1
                wrap: false
                fontStyle: "header_48"
            }
            ' measure Title height
            dummyLabel.update(labelSettings)
            decorations.push({
                "type": "TextItem",
                height: dummyLabel.boundingRect().height
                width: SectionConstants.TEXT_MAX_WIDTH
                content: labelSettings
            })
            decorations.push({
                "type": "Spacer"
                height: 27
            })
        end if

        if strNotEmpty(item.display?.description)
            ' Figure out if Description needs to be focusable or not:
            ' If it fits without ellipsizing, then there's no need to focus on it
            labelSettings = {
                "type": "TextItem"
                fontStyle: "label_24"
                text: item.display.description
                width: SectionConstants.TEXT_MAX_WIDTH
                maxLines: 3
                wrap: true
            }
            dummyLabel.update(labelSettings)
            ' Calling boundingRect() triggers some measuring logic in the label
            ' and [isTextEllipsized] will have a correct value only after calling it, so do that first
            height = dummyLabel.boundingRect().height
            descriptionFocusable = dummyLabel.isTextEllipsized
            ' Reset for next use
            dummyLabel.width = 0

            ' If description is focusable, we can make it an actual row, and add the title/logo as decorations
            ' if it's not, then add all 3 elements to [decorations] and let them be added to the next row
            if descriptionFocusable
                row = createNewSection()
                textItem = row.createChild("AAContentNode")
                textItem.update({ aspectRatio: SectionConstants.TEXT_MAX_WIDTH / height }, true)
                textItem.aa = labelSettings
                row.update({ desiredHeight: height }, true)
                dumpDecorations(row, decorations)

                rows.push(row)
            else
                decorations.push({
                    "type": "TextItem",
                    height: height
                    width: SectionConstants.TEXT_MAX_WIDTH
                    content: labelSettings
                })
            end if
            ' Whether or not Description is focusable, add a spacer before the next line
            decorations.push({
                "type": "Spacer"
                height: 72
            })
        end if
    end for
    return rows
end function

function createNewSection(display = invalid)
    section = createObject("roSGNode", "AAContentNode")
    if display <> invalid
        section.update({ display: display }, true)
    end if
    return section
end function

sub onSectionItemSelected(event)
    index = m.rowList.rowItemSelected ' [rowIndex, itemIndex]
    item = m.rowList.content.getChild(index[0]).getChild(index[1])
    itemType = item.aa.type
    if itemType = "CarouselItem"
        onMediaItemClicked(item.aa.item.media)
    else if itemType = "TextItem"
        Toast.show(`TODO: show dialog with text: ${left(item.aa.text, 10)}...`)
    else if itemType = "Spacer"
        ' No-Op
    else
        Toast.show(`to be impl: type=${itemType}`)
    end if
end sub

sub onMediaItemClicked(media)
    if media = invalid
        Toast.show("Something went wrong (missing media)")
        return
    end if

    if media.live_video = true
        if MediaItemUtils.isEndedLive(media)
            Toast.show("Stream already completed.")
            return
        else if not MediaItemUtils.isStartedLive(media)
            view = CreateObject("roSGNode", "UpcomingVideo")
            view.media = media
            view.property = m.top.property
            router()@.show({ view: view })
            return
        else
            ' This is a LIVE video that's valid to view, continue normally
        end if
    end if

    videoPlayerView = CreateObject("roSGNode", "VideoPlayer")
    videoPlayerView.propertyMedia = {
        propertyId: m.top.property.id
        mediaId: media.id
    }
    router()@.show({ view: videoPlayerView })
end sub

sub dumpDecorations(row, decorations)
    customDecorations = row.customDecorations ?? []
    customDecorations.append(decorations)
    row.update({ customDecorations: customDecorations }, true)
    decorations.clear()
end sub
