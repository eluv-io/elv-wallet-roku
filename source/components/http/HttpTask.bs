import "pkg:/components/stores/stores.bs"
import "pkg:/components/utils/SignOutHelper.bs"
import "pkg:/components/utils/str.bs"
import "pkg:/components/utils/UrlUtil.bs"
import "pkg:/components/utils/promise.bs"

sub init()
    m.top.functionName = "EventLoop"
    m.port = createObject("roMessagePort")
    m.pendingRequests = {}
    saveUserAgent()
    m.top.observeField("request", m.port)

    m.registry = createObject("roRegistrySection", "http")
    m.top.staging = m.registry.read("staging") = "true"
    m.top.observeField("staging", m.port)
end sub

sub saveUserAgent()
    deviceInfo = createObject("roDeviceInfo")
    osVersion = deviceInfo.getOSVersion()
    appInfo = createObject("roAppInfo")
    ' Embed "tvos" to force BE to give us tenant-filtered results
    m.userAgent = `Roku/${osVersion.major}.${osVersion.minor}.${osVersion.revision} (com.eluvio.wallet:${appInfo.getVersion()} tvos-like)`
end sub

sub EventLoop()
    while true
        msg = wait(0, m.port)
        if msg <> invalid
            msgType = type(msg)
            if msgType = "roUrlEvent"
                handleHttpResponse(msg)
            else if msgType = "roSGNodeEvent"
                field = msg.getField()
                if field = "request"
                    observer = msg.getData()
                    if observer <> invalid
                        m.top.request = invalid ' prevent infinite loop after observer.output changes
                        fireHttpRequest(observer)
                    end if
                else if field = "staging"
                    state = msg.getData()
                    Logger.log(`Staging state changed to: ${state}`)
                    m.registry.write("staging", `${state}`)
                    m.registry.flush()
                end if
            end if
        end if
    end while
end sub

sub fireHttpRequest(promise)
    request = createObject("roUrlTransfer")
    request.SetCertificatesFile("common:/certs/ca-bundle.crt")
    request.InitClientCertificates()
    request.RetainBodyOnError(true)
    request.setMessagePort(m.port)

    url = promise.request.url
    if m.top.staging and url.inStr("/as/mw") <> -1
        url = UrlUtil.appendQuery(url, "env", "staging")
    end if
    request.setUrl(url)

    method = promise.request.method
    body = promise.request.body
    request.SetRequest(method)
    headers = getDefaultHeaders()
    request.SetHeaders(headers)

    printRequest(request, body, headers)
    sent = invalid
    if method = "GET"
        sent = request.AsyncGetToString()
    else if method = "HEAD"
        sent = request.AsyncHead()
    else
        'POST, PUT, PATCH, DELETE
        sent = request.AsyncPostFromString(body)
    end if

    if sent
        m.pendingRequests[request.getIdentity().toStr()] = { promise: promise, request: request }
    else
        print "Failed to fire HTTP request to URL: "; promise.request.url
    end if
end sub

sub getDefaultHeaders() as object
    headers = {
        "User-Agent": m.userAgent,
        "Eluvio-User-Agent": m.userAgent,
        "Content-Type": "application/json",
    }

    token = stores.tokenStore().fabricToken
    if strNullOrEmpty(token)
        token = stores.fabricConfigStore().staticToken
    end if

    if strNotEmpty(token)
        headers["Authorization"] = `Bearer ${token}`
    end if

    return headers
end sub

sub printRequest(request as roUrlTransfer, body, headers)
    ' Note this might not be the actual full list of headers, as roku migth inject stuff we don't have access to.
    print `
[HTTP] Request ${request.GetRequest()}: ${request.getUrl()} (Request ID: ${request.getIdentity()})
       Headers: ${formatJson(headers)}
       ${body <> "" ? `Payload: ${body}` : ""}
    `
end sub

sub handleHttpResponse(response as roUrlEvent)
    key = response.getSourceIdentity().toStr()
    request = m.pendingRequests[key]
    if request = invalid
        print `[HTTP] Got an unexpected response. Discarding. (Request ID: ${key})`
        return
    end if
    responseCode = response.getResponseCode()
    skipResolution = handleErrors(request, response)

    url = request.request.getUrl()
    rawResponse = response.getString()
    if rawResponse = ""
        json = {}
    else
        json = parseJson(rawResponse)
        if type(json) = "roArray"
            ' HttpResponse.json can't handle raw arrays, so we have to wrap the response in an AA
            json = { "arr": json }
        end if
    end if
    result = createObject("roSGNode", "HttpResponse")
    result.json = json
    result.code = responseCode
    result.headers = response.getResponseHeaders()
    print `
    [HTTP] Response ${result.code} ${url} (Request ID: ${key})
    Headers: ${formatJson(result.headers)}
    Payload: ${request.promise.request.printResponseBody ? rawResponse : "TRIMMED"}
    `
    m.pendingRequests.Delete(key)
    if not skipResolution then promises.resolve(result, request.promise)
end sub

' Assumes 401/403 happen because of an expired token and signs out
' Returns true if we should skip resolving the original request promise (because we're refreshing the token)
function handleErrors(request, response) as boolean
    responseCode = response.getResponseCode()
    if responseCode = 401 and stores.tokenStore().refreshToken <> invalid
        context = { originalRequest: request }
        ' On refresh complete, retry original request
        promises.chain(stores.tokenStore()@.refreshTokens(), context).then(sub(response, context)
            if response.code = 200
                result = response.json
                Logger.log("Token refresh done. Retrying original request.")
                fireHttpRequest(context.originalRequest.promise)
            else
                Logger.log("Token refresh failed. Signing out.")
                signOutApp("Session expired. Please sign in again.")
            end if
        end sub)
        return true
    end if

    if responseCode = 401 or responseCode = 403
        signOutApp("Session expired. Please sign in again.")
    end if
    return false
end function
